generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========= Utilisateurs & Rôles =========

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  image         String?
  role          Role       @default(TEACHER)
  blocked       Boolean    @default(false)
  emailVerified Boolean   @default(false)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // BetterAuth
  password  Password?
  sessions  Session[]
  accounts  Account[]

  // Prof lié à cet utilisateur (optionnel)
  teacher   Teacher?

  // Qui a modifié une présence (clé étrangère sur Attendance.updatedBy)
  updatedAttendanceRecords Attendance[] @relation("AttendanceUpdatedBy")
  
  // Exclusions créées par cet utilisateur
  exclusionsMade CourseLicenseeExclusion[] @relation("ExclusionMadeBy")
}

enum Role {
  ADMIN
  BUREAU
  TEACHER
}

enum GroupType {
  PRIMA
  J2
  J3
  J4
  J5_JUDO
  J5_JUJITSU
  JUJITSU_JEUNE
  NE_WAZA
  TAISO
  SELF_DEFENSE
  YOGA
}

model Teacher {
  id      Int    @id @default(autoincrement())
  userId  String @unique
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  courses CourseTeacher[]
}

// ========= Métier : Licenciés / Groupes / Cours =========

model Group {
  id           Int                @id @default(autoincrement())
  name         String             @unique
  type         GroupType
  description  String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  
  // Relations
  licensees    LicenseeGroup[]
  courses      CourseGroup[]
}

model Licensee {
  id           Int                @id @default(autoincrement())
  firstName    String
  lastName     String
  dateOfBirth  DateTime
  age          Int                // calculé automatiquement
  externalId   String?            @unique
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  
  // Relations
  groups       LicenseeGroup[]
  attendance   Attendance[]
  exclusions   CourseLicenseeExclusion[]
}

model LicenseeGroup {
  id          Int      @id @default(autoincrement())
  licenseeId  Int
  groupId     Int
  assignedAt  DateTime @default(now())
  
  licensee    Licensee @relation(fields: [licenseeId], references: [id], onDelete: Cascade)
  group       Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@unique([licenseeId, groupId])
}

model Course {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  
  // Relations
  teachers  CourseTeacher[]
  groups    CourseGroup[]
  timetable Timetable[]
  sessions  CourseSession[]
  exclusions CourseLicenseeExclusion[]
}

model CourseGroup {
  id        Int     @id @default(autoincrement())
  courseId  Int
  groupId   Int
  
  course    Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)
  group     Group   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  @@unique([courseId, groupId])
}

model CourseTeacher {
  id        Int     @id @default(autoincrement())
  courseId  Int
  teacherId Int
  assignedAt DateTime @default(now())
  
  course    Course  @relation(fields: [courseId], references: [id], onDelete: Cascade)
  teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  
  @@unique([courseId, teacherId])
}

model Timetable {
  id       Int    @id @default(autoincrement())
  courseId Int
  weekday  Int         // 1=lundi ... 7=dimanche
  startsAt String      // "09:00"
  endsAt   String      // "10:00"
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model CourseSession {
  id         Int       @id @default(autoincrement())
  courseId   Int
  date       DateTime
  course     Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  attendance Attendance[]
  locked     Boolean   @default(false)

  @@unique([courseId, date])
}

enum AttendanceStatus {
  PRESENT
  JUSTIFIED
}

model Attendance {
  id         Int       @id @default(autoincrement())
  sessionId  Int
  licenseeId Int
  status     AttendanceStatus? // null = absence non justifiée
  remark     String?
  updatedBy  String?   // User.id (String)
  updatedAt  DateTime  @updatedAt

  session    CourseSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  licensee   Licensee      @relation(fields: [licenseeId], references: [id], onDelete: Cascade)

  // relation nommée vers User, pour lever l'ambiguïté
  updatedByUser User?      @relation("AttendanceUpdatedBy", fields: [updatedBy], references: [id])

  @@unique([sessionId, licenseeId])
}

model Period {
  id       Int      @id @default(autoincrement())
  label    String
  startsOn DateTime
  endsOn   DateTime
  scope    String?
}

model SchoolYearConfig {
  id             Int @id @default(autoincrement())
  yearStartMonth Int @default(9) // septembre
}

// ========= Exclusions de licenciés par cours =========

model CourseLicenseeExclusion {
  id          Int      @id @default(autoincrement())
  courseId    Int
  licenseeId  Int
  excludedAt  DateTime @default(now())
  excludedBy  String   // User.id qui a fait l'exclusion
  reason      String?  // Raison optionnelle de l'exclusion
  
  // Relations
  course         Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  licensee       Licensee @relation(fields: [licenseeId], references: [id], onDelete: Cascade)
  excludedByUser User     @relation("ExclusionMadeBy", fields: [excludedBy], references: [id])
  
  @@unique([courseId, licenseeId])
  @@index([courseId])
  @@index([licenseeId])
}

// ========= BetterAuth (Prisma Adapter) =========

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String   @id @default(cuid())
  accountId         String
  providerId        String
  userId            String
  password          String?
  accessToken       String?
  refreshToken      String?
  expiresAt         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
}

model Password {
  id        String   @id @default(cuid())
  hash      String
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
