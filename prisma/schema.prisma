generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========= Utilisateurs & Rôles =========

model User {
  id            String     @id @default(cuid())
  email         String     @unique
  name          String?
  image         String?
  role          Role       @default(TEACHER)
  blocked       Boolean    @default(false)
  emailVerified Boolean   @default(false)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // BetterAuth
  password  Password?
  sessions  Session[]
  accounts  Account[]

  // Prof lié à cet utilisateur (optionnel)
  teacher   Teacher?

  // Qui a modifié une présence (clé étrangère sur Attendance.updatedBy)
  updatedAttendanceRecords Attendance[] @relation("AttendanceUpdatedBy")
}

enum Role {
  ADMIN
  BUREAU
  TEACHER
}

enum AgeGroup {
  BABY_JUDO      // 4-5 ans
  POUSSIN        // 6-7 ans  
  BENJAMIN       // 8-9 ans
  MINIME         // 10-11 ans
  CADET          // 12-13 ans
  JUNIOR         // 14-17 ans
  SENIOR         // 18+ ans
}

model Teacher {
  id      Int    @id @default(autoincrement())
  userId  String @unique
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  courses Course[]
}

// ========= Métier : Classes / Cours =========

model Class {
  id       Int      @id @default(autoincrement())
  name     String   @unique
  students Student[]
  courses  Course[]
}

model Student {
  id         Int       @id @default(autoincrement())
  firstName  String
  lastName   String
  externalId String?   @unique
  classId    Int
  class      Class     @relation(fields: [classId], references: [id], onDelete: Cascade)
  attendance Attendance[]
}

model Course {
  id        Int      @id @default(autoincrement())
  name      String
  ageGroup  AgeGroup
  classId   Int
  class     Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  teacherId Int
  teacher   Teacher  @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  timetable Timetable[]
  sessions  CourseSession[]
}

model Timetable {
  id       Int    @id @default(autoincrement())
  courseId Int
  weekday  Int         // 1=lundi ... 7=dimanche
  startsAt String      // "09:00"
  endsAt   String      // "10:00"
  course   Course @relation(fields: [courseId], references: [id], onDelete: Cascade)
}

model CourseSession {
  id         Int       @id @default(autoincrement())
  courseId   Int
  date       DateTime
  course     Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  attendance Attendance[]
  locked     Boolean   @default(false)

  @@unique([courseId, date])
}

enum AttendanceStatus {
  PRESENT
  JUSTIFIED
}

model Attendance {
  id         Int       @id @default(autoincrement())
  sessionId  Int
  studentId  Int
  status     AttendanceStatus? // null = absence non justifiée
  remark     String?
  updatedBy  String?   // User.id (String)
  updatedAt  DateTime  @updatedAt

  session    CourseSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  student    Student       @relation(fields: [studentId], references: [id], onDelete: Cascade)

  // relation nommée vers User, pour lever l’ambiguïté
  updatedByUser User?      @relation("AttendanceUpdatedBy", fields: [updatedBy], references: [id])

  @@unique([sessionId, studentId])
}

model Period {
  id       Int      @id @default(autoincrement())
  label    String
  startsOn DateTime
  endsOn   DateTime
  scope    String?
}

model SchoolYearConfig {
  id             Int @id @default(autoincrement())
  yearStartMonth Int @default(9) // septembre
}

// ========= BetterAuth (Prisma Adapter) =========

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String   @id @default(cuid())
  accountId         String
  providerId        String
  userId            String
  password          String?
  accessToken       String?
  refreshToken      String?
  expiresAt         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expiresAt  DateTime
  createdAt  DateTime @default(now())
}

model Password {
  id        String   @id @default(cuid())
  hash      String
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
